#include "pyb/miniosl.h"
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/numpy.h>
#include <pybind11/operators.h>
#include "state.h"
#include "record.h"
#include "feature.h"
#include "game.h"
#include "impl/bitpack.h"
#include "impl/more.h"
#include <sstream>
#include <iostream>
#include <fstream>
#include <thread>

// namespace py = pybind11;

namespace pyosl {
  using namespace osl;
  Move read_japanese_move(const EffectState& state, std::u8string move, Square last_to=Square());
    
  /** pieces on board as numpy array */
  py::array_t<int8_t> to_np(const BaseState& state);
  /** hand pieces as numpy array */
  py::array_t<int8_t> to_np_hand(const BaseState& state);
  /** squares covered by pieces as numpy array */
  py::array_t<int8_t> to_np_cover(const EffectState& state);

  /** a simple set of state features including board and hands */
  py::array_t<float> to_np_44ch(const BaseState& state);
  /** batch version of to_np_44ch */
  std::pair<py::array_t<float>, py::array_t<int8_t>>
  to_np_batch_44ch(const std::vector<std::array<uint64_t,4>>& batch);
  py::array_t<float> to_np_heuristic(const EffectState& state, bool flipped=false, Move last_move=Move());
  std::tuple<py::array_t<float>, int, int, py::array_t<float>>
  to_np_feature_labels(const StateRecord320& record);

  std::tuple<py::array_t<float>, int, int, py::array_t<float>>
  sample_np_feature_labels(const SubRecord& record);

  /** pack into 256bits */
  py::array_t<uint64_t> to_np_pack(const BaseState& state);
  std::pair<MiniRecord, int> unpack_record(py::array_t<uint64_t> code_seq);

  py::array_t<float> export_heuristic_feature_static(const EffectState&, Move=Move());
  std::pair<py::array_t<float>,osl::GameResult> export_heuristic_feature_after_move_static(Move, const EffectState&);
}


void pyosl::init_state_np(py::module_& m) {
  using namespace pybind11::literals;

  // define the base class prior to the main state class
  typedef osl::BaseState base_t;
  py::class_<base_t>(m, "BaseState", py::dynamic_attr(), "parent of :py:class:`State`.   Please use `State` for usual cases.\n\n"
                     ">>> state = miniosl.State()\n"
                     ">>> state.turn() == miniosl.black\n"
                     "True\n"
                     ">>> state.piece_at(miniosl.Square(5, 9)).ptype() == miniosl.king\n"
                     "True\n"
                     ">>> state.king_square(miniosl.white) == miniosl.Square(5, 1)\n"
                     "True\n"
                     ">>> state.count_hand(miniosl.black, miniosl.pawn)\n"
                     "0\n"
                     )
    .def("turn", &base_t::turn, "player to move")
    .def("piece_at", &base_t::pieceAt, "square"_a, "a piece at given square")
    .def("piece", &base_t::pieceOf, "internal_id"_a)
    .def("count_hand", &base_t::countPiecesOnStand, "color"_a, "ptype"_a)
    .def("king_square", [](const base_t& s, osl::Player P) { return s.kingSquare(P); }, "color"_a)
    .def("to_usi", [](const base_t &s) { return osl::to_usi(s); })
    .def("to_csa", [](const base_t &s) { return osl::to_csa(s); })
    .def("rotate180", &base_t::rotate180,
         "make a rotated state\n\n"
         ">>> s = miniosl.State()\n"
         ">>> print(s.to_csa(), end='')\n"
         "P1-KY-KE-GI-KI-OU-KI-GI-KE-KY\n"
         "P2 * -HI *  *  *  *  * -KA * \n"
         "P3-FU-FU-FU-FU-FU-FU-FU-FU-FU\n"
         "P4 *  *  *  *  *  *  *  *  * \n"
         "P5 *  *  *  *  *  *  *  *  * \n"
         "P6 *  *  *  *  *  *  *  *  * \n"
         "P7+FU+FU+FU+FU+FU+FU+FU+FU+FU\n"
         "P8 * +KA *  *  *  *  * +HI * \n"
         "P9+KY+KE+GI+KI+OU+KI+GI+KE+KY\n"
         "+\n"
         ">>> _ = s.make_move('+7776FU')\n"
         ">>> print(s.rotate180().to_csa(), end='')\n"
         "P1-KY-KE-GI-KI-OU-KI-GI-KE-KY\n"
         "P2 * -HI *  *  *  *  * -KA * \n"
         "P3-FU-FU-FU-FU-FU-FU * -FU-FU\n"
         "P4 *  *  *  *  *  * -FU *  * \n"
         "P5 *  *  *  *  *  *  *  *  * \n"
         "P6 *  *  *  *  *  *  *  *  * \n"
         "P7+FU+FU+FU+FU+FU+FU+FU+FU+FU\n"
         "P8 * +KA *  *  *  *  * +HI * \n"
         "P9+KY+KE+GI+KI+OU+KI+GI+KE+KY\n"
         "+\n")
    .def("hash_code", &osl::hash_code, "64bit int for board and 32bit for (black) hand pieces")
    .def("to_np", &pyosl::to_np, "pieces on board as numpy array")
    .def("to_np_hand", &pyosl::to_np_hand, "pieces on hand as numpy array")
    .def("to_np_44ch", &pyosl::to_np_44ch, "a simple set of state features including board and hands")
    .def("to_np_pack", &pyosl::to_np_pack, "pack into 256bits")
    .def("decode_move_label", [](const base_t &s, int code) { return osl::ml::decode_move_label(code, s); },
         "code"_a,
         "interpret move index generated by :py:meth:`Move.policy_move_label`")
    .def("__repr__", [](const base_t &s) {
      return "<BaseState '" + osl::to_usi(s) + "'>";
    })
    .def("__str__", [](const base_t &s) { return osl::to_usi(s); })
    .def(py::self == py::self)
    .def(py::self != py::self)
    .def("__copy__",  [](const base_t& s) { return base_t(s);})
    .def("__deepcopy__",  [](const base_t& s) { return base_t(s);})
    ;
  // state
  typedef osl::EffectState state_t;
  py::class_<state_t, base_t>(m, "State", py::dynamic_attr(),
                              "shogi state = board position + pieces in hand (mochigoma)")
    .def(py::init())
    .def(py::init<const state_t&>())
    .def(py::init<const osl::BaseState&>())
    .def("reset", &state_t::copyFrom, "src"_a, "re-initialize self copying `src`")
    .def("genmove", [](const state_t &s) {
      osl::MoveVector moves;
      s.generateLegal(moves);
      return moves;
    }, "genmove suitable for most cases (some moves are excluded)\n\n"
      ">>> s = miniosl.State()\n"
      ">>> len(s.genmove())\n"
      "30\n"
      )
    .def("genmove_full", [](const state_t &s) {
      osl::MoveVector moves;
      s.generateWithFullUnpromotions(moves);
      return moves;
    }, "genenerate full moves, including skip-promotion of pawn, bishop, and rook.")
    .def("genmove_check", [](const state_t &s) {
      osl::MoveVector moves;
      s.generateCheck(moves);
      return moves;
    }, "generate check moves only")
    .def("make_move", &state_t::make_move, "move_string"_a, "take usa or csa representation")
    .def("make_move", [](state_t &s, osl::Move move) {
      if (! s.isLegal(move) || ! s.isAcceptable(move))
        throw std::domain_error("move error "+osl::to_csa(move));
      s.makeMove(move);
    }, "move"_a)
    .def("make_move_pass", &state_t::makeMovePass)
    .def("__repr__", [](const state_t &s) {
      return "<State '" + osl::to_usi(s) + "'>";
    })
    .def("__str__", [](const state_t &s) { return osl::to_usi(s); })
    .def("count_cover", py::overload_cast<osl::Player,osl::Square>(&state_t::countEffect, py::const_),
         "color"_a, "sq"_a,
         "the number of pieces reachable to given square\n\n"
         ">>> s = miniosl.State()\n"
         ">>> s.count_cover(miniosl.black, miniosl.Square(1, 7))\n"
         "2\n"
         ">>> s.count_cover(miniosl.black, miniosl.Square(5, 7))\n"
         "0\n"
         ">>> s.count_cover(miniosl.black, miniosl.Square(9, 7))\n"
         "3\n"
         )
    .def("pieces_cover", [](const state_t& s, osl::Player P, osl::Square target) {
      return (s.piecesOnBoard(P)&s.effectAt(target)).to_ullong();
    }, "color"_a, "square"_a, "the bitset of piece-ids reachable to given square")
    .def("in_check", py::overload_cast<>(&state_t::inCheck, py::const_))
    .def("in_checkmate", py::overload_cast<>(&state_t::inCheckmate, py::const_))
    .def("to_move", &state_t::to_move, "move_string"_a, "parse and return move\n\n"
         ">>> s = miniosl.State()\n"
         ">>> s.to_move('+2726FU') == s.to_move('2g2f')\n"
         "True\n"
         )
    .def("read_japanese_move", &pyosl::read_japanese_move,
         "move"_a, "last_to"_a=Square(),
         "parse and return move")
    .def("is_legal", &state_t::isLegal, "move"_a)
    .def("to_np_cover", &pyosl::to_np_cover, "squares covered by pieces as numpy array")
    .def("encode_move", [](const state_t& s, osl::Move m) { return osl::bitpack::encode12(s, m); },
         "move"_a,
         ":meta private: compress move into 12bits uint")
    .def("decode_move", [](const state_t& s, uint32_t c) { return osl::bitpack::decode_move12(s, c); },
         "code"_a,
         ":meta private: uncompress move from 12bits uint generated by :py:meth:`encode_move`")
    .def("try_checkmate_1ply", &state_t::tryCheckmate1ply, "try to find a checkmate move")
    .def("__copy__",  [](const state_t& s) { return state_t(s);})
    .def("__deepcopy__",  [](const state_t& s) { return state_t(s);})
    .def("to_np_heuristic", &pyosl::to_np_heuristic, "flipped"_a=false, "last_move"_a=osl::Move(), 
         "standard set of features")
    ;

  py::class_<osl::StateRecord256>(m, "StateRecord256", py::dynamic_attr(),
                                  "training record as a (state, move, and result) tuple in 32 bytes")
    .def_readonly("state", &osl::StateRecord256::state, ":py:class:`BaseState`, input in training")
    .def_readonly("move", &osl::StateRecord256::next, ":py:class:`Move` to play, label in training")
    .def_readonly("result", &osl::StateRecord256::result, ":py:class:`GameResult`, label in training")
    .def_readonly("flipped", &osl::StateRecord256::flipped, "bool, true when the original state was white to move")
    .def("to_bitset", &osl::StateRecord256::to_bitset)
    .def("restore", &osl::StateRecord256::restore, "code"_a)
    .def("to_np_44ch", [](const osl::StateRecord256& obj) {
      return pyosl::to_np_44ch(obj.state);
    })
    .def("to_np_heuristic", [](const osl::StateRecord256& obj) {
      osl::EffectState state(obj.state);
      return pyosl::to_np_heuristic(state, obj.flipped);
    }, "standard set of features")
    .def("__copy__",  [](const osl::StateRecord256& r) { return osl::StateRecord256(r);})
    .def("__deepcopy__",  [](const osl::StateRecord256& r) { return osl::StateRecord256(r);})
    ;  
  py::class_<osl::StateRecord320>(m, "StateRecord320", py::dynamic_attr(),
                                  "training record as a (state-with-5-len-history, move, and result) tuple in 40 bytes")
    .def_readonly("base", &osl::StateRecord320::base, ":py:class:`BaseState`")
    .def_readonly("history", &osl::StateRecord320::history, "last five :py:class:`Move` s, additional input in training")
    .def("to_bitset", &osl::StateRecord320::to_bitset)
    .def("restore", &osl::StateRecord320::restore, "code"_a)
    .def("make_state", &osl::StateRecord320::make_state, "target state to learn")
    .def("last_move", &osl::StateRecord320::last_move, "last :py:class:`Move` played")
    .def("to_np_heuristic", [](const osl::StateRecord320& obj) {
      osl::EffectState state(obj.make_state());
      return pyosl::to_np_heuristic(state, obj.base.flipped, obj.last_move());
    }, "standard set of features")
    .def("to_np_feature_labels", &pyosl::to_np_feature_labels,
         "tuple of standard set of features, move label, value label, and others")
    .def("__copy__",  [](const osl::StateRecord320& r) { return osl::StateRecord320(r);})
    .def("__deepcopy__",  [](const osl::StateRecord320& r) { return osl::StateRecord320(r);})
    .def_static("test_item", [](){ osl::StateRecord320 r; r.base.next = Move(Square(7,7),Square(7,6),PAWN,Ptype_EMPTY,false,BLACK); return r; })  // for test
    ;  
  py::class_<osl::SubRecord>(m, "SubRecord", py::dynamic_attr(), "subset of MiniRecord")
    .def(py::init<const MiniRecord&>())
    .def_readonly("moves", &osl::SubRecord::moves, "list of :py:class:`Move` s")
    .def_readonly("result", &osl::SubRecord::result, ":py:class:`GameResult`")
    .def_readonly("final_move", &osl::SubRecord::final_move, "resign or win declaration in :py:class:`Move`")
    .def("sample_feature_labels", &pyosl::sample_np_feature_labels, "randomly samle index and call export_feature_labels()")
    .def("make_state", &osl::SubRecord::make_state, "n"_a, "make a state after the first `n` moves")
    ;
  
  // functions depends on np
  m.def("unpack_record", &pyosl::unpack_record, "read record from np.array encoded by MiniRecord.pack_record");
  m.def("to_np_batch_44ch", &pyosl::to_np_batch_44ch, "batch conversion of to_np_44ch");
  m.def("to_state_label_tuple256", [](std::array<uint64_t,4> binary){
    osl::StateRecord256 obj;
    obj.restore(binary);
    return obj;
  }, "code"_a, "unpack four uint64s to get StateRecord256");
  m.def("to_state_label_tuple320", [](std::array<uint64_t,5> binary){
    osl::StateRecord320 obj;
    obj.restore(binary);
    return obj;
  }, "code"_a, "unpack five uint64s to get StateRecord320");
  m.def("export_heuristic_feature", &pyosl::export_heuristic_feature_static,
        "state"_a, "last_move"_a=osl::Move());
  m.def("export_heuristic_feature_after_move", &pyosl::export_heuristic_feature_after_move_static,
        "move"_a, "state"_a);
}

osl::Move pyosl::read_japanese_move(const EffectState& state, std::u8string move, Square last_to) {
  try {
    return kanji::to_move(move, state, last_to);
  }
  catch (std::exception& e) {
  }
  return Move::PASS(state.turn());
}

py::array_t<int8_t> pyosl::to_np(const BaseState& state) {
  auto feature = py::array_t<int8_t>(9*9);
  auto buffer = feature.request();
  auto ptr = static_cast<int8_t*>(buffer.ptr);
  auto board = ml::board_dense_feature(state);
  std::ranges::copy(board, ptr);
  return feature.reshape({9, 9});
}

py::array_t<int8_t> pyosl::to_np_hand(const BaseState& state) {
  const int N = piece_stand_order.size();
  auto feature = py::array_t<int8_t>(N*2);
  auto buffer = feature.request();
  auto ptr = static_cast<int8_t*>(buffer.ptr);
  auto hand = ml::hand_dense_feature(state);
  std::ranges::copy(hand, ptr);
  return feature.reshape({2, 7});
}

py::array_t<int8_t> pyosl::to_np_cover(const EffectState& state) {
  auto feature = py::array_t<int8_t>(9*9*2);
  auto buffer = feature.request();
  auto ptr = static_cast<int8_t*>(buffer.ptr);
  for (auto pl: players)
    for (int y: board_y_range())
      for (int x: board_x_range())
        ptr[(y-1)*9+(x-1)+81*idx(pl)] = state.countEffect(pl, Square(x,y));
  return feature.reshape({-1, 9, 9});
}

py::array_t<uint64_t> pyosl::to_np_pack(const BaseState& state) {
  auto packed = py::array_t<uint64_t>(4);
  auto buffer = packed.request();
  auto ptr = static_cast<uint64_t*>(buffer.ptr);
  osl::StateRecord256 instance {state};
  auto bs = instance.to_bitset();
  for (int i: std::views::iota(0,4))
    ptr[i] = bs[i];
  return packed;
}

std::pair<osl::MiniRecord, int> pyosl::unpack_record(py::array_t<uint64_t> code_seq) {
  auto buf = code_seq.request();
  auto ptr = static_cast<const uint64_t*>(buf.ptr);
  MiniRecord record;
  auto n = bitpack::read_binary_record(ptr, record);
  return {record, n};
}

py::array_t<float> pyosl::to_np_44ch(const osl::BaseState& state) {
  /*  - 14 for white pieces: [ppawn, plance, pknight, psilver, pbishop, prook,
   *    king, gold, pawn, lance, knight, silver, bishop, rook]
   *  - 2 for empty and ones
   *  - 14 for black pieces
   *  - 14 for hand pieces
   */
  auto feature = py::array_t<float>(9*9*ml::basic_channels);
  auto buffer = feature.request();
  auto ptr = static_cast<float_t*>(buffer.ptr);
  ml::helper::write_np_44ch(state, ptr);
  return feature;
}

std::pair<py::array_t<float>, py::array_t<int8_t>>
pyosl::to_np_batch_44ch(const std::vector<std::array<uint64_t,4>>& batch) {
  auto batch_feature = py::array_t<float_t>(batch.size()*9*9*ml::basic_channels);
  auto buffer = batch_feature.request();
  auto ptr = static_cast<float_t*>(buffer.ptr);
  auto batch_label = py::array_t<int8_t>(batch.size());
  auto label_buffer = batch_label.request();
  auto label_ptr = static_cast<int8_t*>(label_buffer.ptr);

  auto convert = [&](int l, int r) {
    for (int i=l; i<r; ++i) {
      const auto& binary = batch[i];
      osl::StateRecord256 obj;
      obj.restore(binary);
      ml::helper::write_np_44ch(obj.state, &ptr[i*9*9*ml::basic_channels]);
      label_ptr[i] = obj.next.to().index81();
    }
  };
  int c = batch.size() / 2;
  std::thread t1(convert, 0, c);
  std::thread t2(convert, c, batch.size());
  t1.join();
  t2.join();
    
  return {batch_feature.reshape({-1, ml::basic_channels, 9, 9}), batch_label};
}

py::array_t<float> pyosl::to_np_heuristic(const EffectState& state, bool flipped, Move last_move) {
  auto feature = py::array_t<float>(9*9*ml::channel_id.size());
  auto buffer = feature.request();
  auto ptr = static_cast<float_t*>(buffer.ptr);

  ml::helper::write_np_44ch(state, ptr);
  ml::helper::write_np_additional(state, flipped, last_move, ptr + 9*9*ml::basic_channels);

  return feature.reshape({-1, 9, 9});
}

std::tuple<py::array_t<float>, int, int, py::array_t<float>>
pyosl::to_np_feature_labels(const StateRecord320& record) {
  auto aux_feature = py::array_t<float>(9*9*12);
  auto aux_buffer = aux_feature.request();
  auto aux_ptr = static_cast<float_t*>(aux_buffer.ptr);

  osl::EffectState state(record.make_state());
  ml::helper::write_np_aftermove(state, record.base.next, aux_ptr);

  return {pyosl::to_np_heuristic(state, record.base.flipped, record.last_move()),
          ml::policy_move_label(record.base.next), ml::value_label(record.base.result),
          aux_feature.reshape({-1, 9, 9})};
}

py::array_t<float> pyosl::export_heuristic_feature_static(const EffectState& state, Move last_move) {
  auto feature = py::array_t<float>(9*9*ml::channel_id.size());
  auto buffer = feature.request();
  auto ptr = static_cast<float_t*>(buffer.ptr);
  GameManager::export_heuristic_feature(state, last_move, ptr);
  return feature.reshape({-1, 9, 9});
}

std::pair<py::array_t<float>,osl::GameResult>
pyosl::export_heuristic_feature_after_move_static(Move move, const EffectState& state) {
  auto feature = py::array_t<float>(9*9*ml::channel_id.size());
  auto buffer = feature.request();
  auto ptr = static_cast<float_t*>(buffer.ptr);
  auto terminal = GameManager::export_heuristic_feature_after(move, state, ptr);
  return std::make_pair(feature.reshape({-1, 9, 9}), terminal);
}


std::tuple<py::array_t<float>, int, int, py::array_t<float>>
pyosl::sample_np_feature_labels(const SubRecord& record) {
  auto feature = py::array_t<float>(9*9*ml::channel_id.size());
  auto buffer = feature.request();
  auto ptr = static_cast<float_t*>(buffer.ptr);

  auto aux_feature = py::array_t<float>(9*9*12);
  auto aux_buffer = aux_feature.request();
  auto aux_ptr = static_cast<float_t*>(aux_buffer.ptr);

  int move_label, value_label;
  record.sample_feature_labels(ptr, move_label, value_label, aux_ptr);
  return {feature.reshape({-1, 9, 9}), move_label, value_label, aux_feature.reshape({-1, 9, 9})};
}


